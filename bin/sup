#!/bin/sh
#
# sup(1) - do <whatever SCM> update
#
# Copyright (c) 2008-2017 Akinori MUSHA
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

main () {
    while getopts qr opt; do
        case "$opt" in
            q)
                OPT_q=t
                ;;
            r)
                OPT_r=t
                ;;
            *)
                echo "$0: illegal option -- $OPTARG" >&2
                exit 64
        esac
    done

    shift $((OPTIND - 1))

    case "$(basename "$0")" in
        sup)
            sup "${@:-.}"
            ;;
        *)
            vcs "${@:-.}"
            ;;
    esac
}

warn () {
    [ -n "$OPT_q" ] ||
        echo "$0: $@" >&2
}

sh_escape () {
    case "$*" in
        '')
            echo "''"
            ;;
        *[!A-Za-z0-9_.,:/@-]*)
            awk '
                BEGIN {
                    n = ARGC - 1
                    for (i = 1; i <= n; i++) {
                        s = ARGV[i]
                        gsub(/[^\nA-Za-z0-9_.,:\/@-]/, "\\\\&", s)
                        gsub(/\n/, "\"\n\"", s)
                        printf "%s", s
                        if (i != n) printf " "
                    }
                    exit 0
                }
                ' "$@"
            ;;
        *)
            printf '%s' "$*" 
            ;;
    esac
}

dir_of () {
    local file="${1:-.}"; shift
    if [ -d "$file" ]; then
        echo "$file"
    else
        dirname "$file"
    fi
}

vcs_of () {
    local file="${1:-.}" dir; shift
    (
        dir="$(dir_of "$file")"

        cd "$dir" || exit

        if [ -f config -a -d objects -a -d refs ]; then
            case "$dir" in
                ?*.git)
                    echo git-bare
                    exit
                    ;;
            esac
        fi

        (
        while :; do
            if [ -d .git ]; then
                if [ -d .git/svn ]; then
                    if [ -z "$(find .git/svn -type f -print)" ]; then
                        rm -rf .git/svn
                        echo git
                    else
                        echo git-svn
                    fi
                else
                    echo git
                fi
                exit
            elif [ -d .hg ]; then
                echo hg
                exit
            elif [ -d .bzr ]; then
                echo bzr
                exit
            elif [ -d .svn ]; then
                echo svn
                exit
            fi

            if [ "$(pwd)" = / ]; then
                break
            fi
            cd -P ..
        done
        )

        if [ -d "$dir"/CVS ]; then
            echo cvs
            exit
        fi

        exit 1
    )
}

setup () {
    trap 'exit 129' 1
    trap 'exit 130' 2
    trap 'exit 131' 3
    trap 'exit 143' 15
}

handle_status () {
    local ret=$1

    [ -n "$ret" ] || return

    if [ $ret -gt 128 ]; then
        if [ $ret -le 165 ]; then
            kill -$((ret - 128)) $$
            sleep 3
        fi
        exit "$ret"
    fi
}

sup () {
    local file ret=0 dir

    for file; do
        do_sup "$(vcs_of "$file")" "$file" || ret="$?"
        handle_status $ret
        if [ -n "$OPT_r" -a -f "$file/.sup" ]; then
            eval "sup $(subdirs_escaped "$file")" || ret="$?"
            handle_status $ret
        fi
    done

    return $ret
}

do_sup () {
    local vcs="$1" file="$2"
    local dir="$(dir_of "$file")"
    local ret=0

    if [ -z "$vcs" ]; then
        warn "VCS unknown: $file"
        return 1
    fi

    case "$vcs" in
        svn)
            echo "[Updating \`$file' with $vcs]"
            ( setup; svn_upgrade "$file"; svn_update "$file" )
            ;;
        cvs)
            echo "[Updating \`$file' with $vcs]"
            if [ -d "$file" ]; then
                ( setup; cd "$file" && cvs update )
            else
                ( setup; cd "$dir" && cvs update "$(basename "$file")" )
            fi
            ;;
        git|git-svn)
            if [ "$vcs" = git ]; then
                echo "[Updating \`$file' with $vcs]"
            else
                echo "[Updating \`$file' with git + $vcs]"
            fi
            ( setup; cd "$dir" && {
                    if [ "$vcs" = git-svn ]; then
                        git svn fetch || exit
                    fi
                    if git_remote_update; then
                        local="$(git symbolic-ref HEAD 2>/dev/null)"
                        if [ -n "$local" ]; then
                            remote="$(git for-each-ref --format='%(upstream:short)' "$local" 2>/dev/null)"
                            if [ -n "$remote" ]; then
                                git rebase "$remote" || exit
                            fi
                        fi
                    fi
                    if [ "$vcs" = git-svn ]; then
                        git svn rebase -l
                    fi
                    git submodule update --init --recursive
                } )
            ;;
        git-bare)
            echo "[Updating \`$file' with $vcs]"
            ( setup; GIT_DIR="$dir" git fetch )
            ;;
        hg)
            echo "[Updating \`$file' with $vcs]"
            if [ -d "$file" ]; then
                ( setup; cd "$file" && hg pull -u )
            else
                ( setup; cd "$dir" && {
                        hg pull
                        hg update "$file"
                    } )
            fi
            ;;
        bzr)
            echo "[Updating \`$file' with $vcs]"
            if [ -d "$file" ]; then
                ( setup; cd "$file" && bzr update && bzr merge )
            else
                ( setup; cd "$dir" && {
                        bzr update
                        bzr merge "$file"
                    } )
            fi
            ;;
        *)
            warn "Skipping \`$file'"
            ;;
    esac
}

subdirs_escaped () {
    local dir=$1 expr subdir dir_escaped

    [ -f "$dir/.sup" ] || return

    expr=$(
        include=
        exclude=
        while read -r pat; do
            case "$pat" in
                [#]*)
                    continue
                    ;;
                [-\!]*)
                    pat=${pat#?}
                    pat=$(expr "X$pat" : 'X[ 	]*\(.*\)[ 	]*$')
                    [ -n "$pat" ] || continue
                    exclude="${exclude:+"$exclude -o "}-name $(sh_escape "$pat")"
                    ;;
                [+]*|*)
                    pat=${pat#+}
                    pat=$(expr "X$pat" : 'X[ 	]*\(.*\)[ 	]*$')
                    [ -n "$pat" ] || continue
                    include="${include:+"$include -o "}-name $(sh_escape "$pat")"
            esac
        done < "$dir/.sup"
        if [ -n "$include" ]; then
            printf "%s" "'(' $include ')'"${exclude:+" '!' '(' $exclude ')'"}
        fi
    )

    [ -n "$expr" ] || return

    dir_escaped=$(sh_escape "$dir")

    eval "find \"\$dir_escaped\" '!' -path \"\$dir_escaped\" -prune '!' -type l -type d $expr" |
        sort |
        while read -r subdir; do
            printf ' %s' "$(sh_escape "$subdir")"
        done
}

vcs () {
    local file ret=0

    for file; do
        local vcs="$(vcs_of "$file")" 

        if [ -z "$vcs" ]; then
            warn "VCS unknown: $file"
            ret=1
        fi

        echo "$vcs"
    done

    return "$ret"
}

svn_upgrade () {
    local dir="$1" output
    if [ -f "$dir" ]; then
        dir="$(dirname "$dir")"
    fi
    (
        cd "$dir" || exit 1
        output="$(svn upgrade 2>&1)"
        case "$output" in
            '')
                exit
                ;;
            'svn: E155019:'*" root is '"*"'")
                svn upgrade "$(expr "$output" : ".* root is '\\(.*\\)'.*")"
                exit
                ;;
            *)
                exit 1
        esac
    )
}

svn_update () {
    local file="$1"
    ( cd "$(dirname "$file")" && svn up "$(basename "$file")" )
}

git_remote_update () {
    if { type hub && type ruby; } >/dev/null 2>&1; then
        ruby -e 'rs=`git remote`.split;m,=%w[upstream github origin]&rs|rs;m&&fork{puts"Fetching "<<m;exec"hub -c gc.auto=0 sync"};(rs-[m]).each{|r|fork{exec *%w[git -c gc.auto=0 remote update -p]<<r}};exit Process.waitall.map{|p,s|s.exitstatus}.max||0'
    elif xargs -P1 </dev/null >/dev/null 2>&1; then
        git remote | xargs -P5 -n1 git -c gc.auto=0 remote update --prune
    else
        git remote update --prune
    fi
}

main "$@"
